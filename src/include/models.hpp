
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_bama_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_bama_model");
    reader.add_event(103, 103, "end", "model_bama_model");
    return reader;
}

class model_bama_model : public prob_grad {
private:
    int N;
    int T;
    vector<int> obs_to_t;
    int N_ag;
    vector<int> obs_to_ag;
    vector_d y;
public:
    model_bama_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_bama_model(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_bama_model_namespace::model_bama_model";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("obs_to_t", "N", N);
            context__.validate_dims("data initialization", "obs_to_t", "int", context__.to_vec(N));
            validate_non_negative_index("obs_to_t", "N", N);
            obs_to_t = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("obs_to_t");
            pos__ = 0;
            size_t obs_to_t_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < obs_to_t_limit_0__; ++i_0__) {
                obs_to_t[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "N_ag", "int", context__.to_vec());
            N_ag = int(0);
            vals_i__ = context__.vals_i("N_ag");
            pos__ = 0;
            N_ag = vals_i__[pos__++];
            validate_non_negative_index("obs_to_ag", "N", N);
            context__.validate_dims("data initialization", "obs_to_ag", "int", context__.to_vec(N));
            validate_non_negative_index("obs_to_ag", "N", N);
            obs_to_ag = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("obs_to_ag");
            pos__ = 0;
            size_t obs_to_ag_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < obs_to_ag_limit_0__; ++i_0__) {
                obs_to_ag[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("y", "N", N);
            context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
            validate_non_negative_index("y", "N", N);
            y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
            vals_r__ = context__.vals_r("y");
            pos__ = 0;
            size_t y_i_vec_lim__ = N;
            for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
                y[i_vec__] = vals_r__[pos__++];
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"obs_to_t[k0__]",obs_to_t[k0__],1);
            }
            check_greater_or_equal(function__,"N_ag",N_ag,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"obs_to_ag[k0__]",obs_to_ag[k0__],1);
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("omega_ag", "N_ag", N_ag);
            num_params_r__ += N_ag;
            validate_non_negative_index("omega_t", "T", T);
            num_params_r__ += T;
            validate_non_negative_index("sigma", "T", T);
            num_params_r__ += T;
        validate_non_negative_index("mu_ag", "N_ag", N_ag);
            validate_non_negative_index("mu_ag", "T", T);
            num_params_r__ += N_ag * T;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            validate_non_negative_index("mu0", "T", T);
            num_params_r__ += T;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_bama_model() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("omega_ag")))
            throw std::runtime_error("variable omega_ag missing");
        vals_r__ = context__.vals_r("omega_ag");
        pos__ = 0U;
        validate_non_negative_index("omega_ag", "N_ag", N_ag);
        context__.validate_dims("initialization", "omega_ag", "double", context__.to_vec(N_ag));
        std::vector<double> omega_ag(N_ag,double(0));
        for (int i0__ = 0U; i0__ < N_ag; ++i0__)
            omega_ag[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_ag; ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,omega_ag[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable omega_ag: ") + e.what());
        }

        if (!(context__.contains_r("omega_t")))
            throw std::runtime_error("variable omega_t missing");
        vals_r__ = context__.vals_r("omega_t");
        pos__ = 0U;
        validate_non_negative_index("omega_t", "T", T);
        context__.validate_dims("initialization", "omega_t", "double", context__.to_vec(T));
        std::vector<double> omega_t(T,double(0));
        for (int i0__ = 0U; i0__ < T; ++i0__)
            omega_t[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < T; ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,omega_t[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable omega_t: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "T", T);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(T));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(T));
        for (int j1__ = 0U; j1__ < T; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("mu_ag")))
            throw std::runtime_error("variable mu_ag missing");
        vals_r__ = context__.vals_r("mu_ag");
        pos__ = 0U;
        validate_non_negative_index("mu_ag", "N_ag", N_ag);
        validate_non_negative_index("mu_ag", "T", T);
        context__.validate_dims("initialization", "mu_ag", "matrix_d", context__.to_vec(N_ag,T));
        matrix_d mu_ag(static_cast<Eigen::VectorXd::Index>(N_ag),static_cast<Eigen::VectorXd::Index>(T));
        for (int j2__ = 0U; j2__ < T; ++j2__)
            for (int j1__ = 0U; j1__ < N_ag; ++j1__)
                mu_ag(j1__,j2__) = vals_r__[pos__++];
        try {
            writer__.matrix_lb_unconstrain(0,mu_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_ag: ") + e.what());
        }

        if (!(context__.contains_r("alpha_ag")))
            throw std::runtime_error("variable alpha_ag missing");
        vals_r__ = context__.vals_r("alpha_ag");
        pos__ = 0U;
        context__.validate_dims("initialization", "alpha_ag", "double", context__.to_vec());
        double alpha_ag(0);
        alpha_ag = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,alpha_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_ag: ") + e.what());
        }

        if (!(context__.contains_r("beta_ag")))
            throw std::runtime_error("variable beta_ag missing");
        vals_r__ = context__.vals_r("beta_ag");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta_ag", "double", context__.to_vec());
        double beta_ag(0);
        beta_ag = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,beta_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_ag: ") + e.what());
        }

        if (!(context__.contains_r("phi_ag")))
            throw std::runtime_error("variable phi_ag missing");
        vals_r__ = context__.vals_r("phi_ag");
        pos__ = 0U;
        context__.validate_dims("initialization", "phi_ag", "double", context__.to_vec());
        double phi_ag(0);
        phi_ag = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,phi_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_ag: ") + e.what());
        }

        if (!(context__.contains_r("lambda_ag")))
            throw std::runtime_error("variable lambda_ag missing");
        vals_r__ = context__.vals_r("lambda_ag");
        pos__ = 0U;
        context__.validate_dims("initialization", "lambda_ag", "double", context__.to_vec());
        double lambda_ag(0);
        lambda_ag = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0.10000000000000001,lambda_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_ag: ") + e.what());
        }

        if (!(context__.contains_r("phi_t")))
            throw std::runtime_error("variable phi_t missing");
        vals_r__ = context__.vals_r("phi_t");
        pos__ = 0U;
        context__.validate_dims("initialization", "phi_t", "double", context__.to_vec());
        double phi_t(0);
        phi_t = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,phi_t);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_t: ") + e.what());
        }

        if (!(context__.contains_r("lambda_t")))
            throw std::runtime_error("variable lambda_t missing");
        vals_r__ = context__.vals_r("lambda_t");
        pos__ = 0U;
        context__.validate_dims("initialization", "lambda_t", "double", context__.to_vec());
        double lambda_t(0);
        lambda_t = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0.10000000000000001,lambda_t);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_t: ") + e.what());
        }

        if (!(context__.contains_r("mu0")))
            throw std::runtime_error("variable mu0 missing");
        vals_r__ = context__.vals_r("mu0");
        pos__ = 0U;
        validate_non_negative_index("mu0", "T", T);
        context__.validate_dims("initialization", "mu0", "vector_d", context__.to_vec(T));
        vector_d mu0(static_cast<Eigen::VectorXd::Index>(T));
        for (int j1__ = 0U; j1__ < T; ++j1__)
            mu0(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu0);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu0: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            vector<T__> omega_ag;
            size_t dim_omega_ag_0__ = N_ag;
            omega_ag.reserve(dim_omega_ag_0__);
            for (size_t k_0__ = 0; k_0__ < dim_omega_ag_0__; ++k_0__) {
                if (jacobian__)
                    omega_ag.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    omega_ag.push_back(in__.scalar_lub_constrain(0,1));
            }

            vector<T__> omega_t;
            size_t dim_omega_t_0__ = T;
            omega_t.reserve(dim_omega_t_0__);
            for (size_t k_0__ = 0; k_0__ < dim_omega_t_0__; ++k_0__) {
                if (jacobian__)
                    omega_t.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    omega_t.push_back(in__.scalar_lub_constrain(0,1));
            }

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,T,lp__);
            else
                sigma = in__.vector_lb_constrain(0,T);

            Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  mu_ag;
            (void) mu_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_ag = in__.matrix_lb_constrain(0,N_ag,T,lp__);
            else
                mu_ag = in__.matrix_lb_constrain(0,N_ag,T);

            T__ alpha_ag;
            (void) alpha_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_ag = in__.scalar_lb_constrain(0,lp__);
            else
                alpha_ag = in__.scalar_lb_constrain(0);

            T__ beta_ag;
            (void) beta_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_ag = in__.scalar_lb_constrain(0,lp__);
            else
                beta_ag = in__.scalar_lb_constrain(0);

            T__ phi_ag;
            (void) phi_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_ag = in__.scalar_lub_constrain(0,1,lp__);
            else
                phi_ag = in__.scalar_lub_constrain(0,1);

            T__ lambda_ag;
            (void) lambda_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_ag = in__.scalar_lb_constrain(0.10000000000000001,lp__);
            else
                lambda_ag = in__.scalar_lb_constrain(0.10000000000000001);

            T__ phi_t;
            (void) phi_t;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_t = in__.scalar_lub_constrain(0,1,lp__);
            else
                phi_t = in__.scalar_lub_constrain(0,1);

            T__ lambda_t;
            (void) lambda_t;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_t = in__.scalar_lb_constrain(0.10000000000000001,lp__);
            else
                lambda_t = in__.scalar_lb_constrain(0.10000000000000001);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu0;
            (void) mu0;  // dummy to suppress unused var warning
            if (jacobian__)
                mu0 = in__.vector_constrain(T,lp__);
            else
                mu0 = in__.vector_constrain(T);


            // transformed parameters
            T__ a_ag;
            (void) a_ag;  // dummy to suppress unused var warning

            stan::math::initialize(a_ag, DUMMY_VAR__);
            stan::math::fill(a_ag,DUMMY_VAR__);
            T__ b_ag;
            (void) b_ag;  // dummy to suppress unused var warning

            stan::math::initialize(b_ag, DUMMY_VAR__);
            stan::math::fill(b_ag,DUMMY_VAR__);
            T__ a_t;
            (void) a_t;  // dummy to suppress unused var warning

            stan::math::initialize(a_t, DUMMY_VAR__);
            stan::math::fill(a_t,DUMMY_VAR__);
            T__ b_t;
            (void) b_t;  // dummy to suppress unused var warning

            stan::math::initialize(b_t, DUMMY_VAR__);
            stan::math::fill(b_t,DUMMY_VAR__);
            validate_non_negative_index("soft_z", "2", 2);
            validate_non_negative_index("soft_z", "N", N);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > soft_z(N, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(2))));
            stan::math::initialize(soft_z, DUMMY_VAR__);
            stan::math::fill(soft_z,DUMMY_VAR__);


            stan::math::assign(a_ag, (lambda_ag * phi_ag));
            stan::math::assign(b_ag, (lambda_ag * (1 - phi_ag)));
            stan::math::assign(a_t, (lambda_t * phi_t));
            stan::math::assign(b_t, (lambda_t * (1 - phi_t)));
            for (int n = 1; n <= N; ++n) {

                stan::math::assign(get_base1_lhs(get_base1_lhs(soft_z,n,"soft_z",1),1,"soft_z",2), (log((1 - (get_base1(omega_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),"omega_ag",1) * get_base1(omega_t,get_base1(obs_to_t,n,"obs_to_t",1),"omega_t",1)))) + normal_log(get_base1(y,n,"y",1),get_base1(mu0,get_base1(obs_to_t,n,"obs_to_t",1),"mu0",1),get_base1(sigma,get_base1(obs_to_t,n,"obs_to_t",1),"sigma",1))));
                stan::math::assign(get_base1_lhs(get_base1_lhs(soft_z,n,"soft_z",1),2,"soft_z",2), (log((get_base1(omega_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),"omega_ag",1) * get_base1(omega_t,get_base1(obs_to_t,n,"obs_to_t",1),"omega_t",1))) + normal_log(get_base1(y,n,"y",1),(get_base1(mu0,get_base1(obs_to_t,n,"obs_to_t",1),"mu0",1) + get_base1(mu_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),get_base1(obs_to_t,n,"obs_to_t",1),"mu_ag",1)),get_base1(sigma,get_base1(obs_to_t,n,"obs_to_t",1),"sigma",1))));
            }

            // validate transformed parameters
            if (stan::math::is_uninitialized(a_ag)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: a_ag";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(b_ag)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b_ag";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(a_t)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: a_t";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(b_t)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b_t";
                throw std::runtime_error(msg__.str());
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                for (int i1__ = 0; i1__ < 2; ++i1__) {
                    if (stan::math::is_uninitialized(soft_z[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: soft_z" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"a_ag",a_ag,0);
            check_greater_or_equal(function__,"b_ag",b_ag,0);
            check_greater_or_equal(function__,"a_t",a_t,0);
            check_greater_or_equal(function__,"b_t",b_t,0);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_less_or_equal(function__,"soft_z[k0__]",soft_z[k0__],0);
            }

            // model body

            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 10));
            lp_accum__.add(beta_log<propto__>(phi_ag, 1, 1));
            lp_accum__.add(pareto_log<propto__>(lambda_ag, 0.10000000000000001, 1.5));
            lp_accum__.add(beta_log<propto__>(phi_t, 1, 1));
            lp_accum__.add(pareto_log<propto__>(lambda_t, 0.10000000000000001, 1.5));
            lp_accum__.add(beta_log<propto__>(omega_ag, a_ag, b_ag));
            lp_accum__.add(beta_log<propto__>(omega_t, a_t, b_t));
            lp_accum__.add(uniform_log<propto__>(alpha_ag, 0, 1000));
            lp_accum__.add(uniform_log<propto__>(beta_ag, 0, 1000));
            lp_accum__.add(normal_log<propto__>(mu0, 0, 0.5));
            for (int n = 1; n <= N_ag; ++n) {

                lp_accum__.add(gamma_log<propto__>(get_base1(mu_ag,n,"mu_ag",1), alpha_ag, beta_ag));
            }
            for (int n = 1; n <= N; ++n) {

                lp_accum__.add(log_sum_exp(get_base1(soft_z,n,"soft_z",1)));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("omega_ag");
        names__.push_back("omega_t");
        names__.push_back("sigma");
        names__.push_back("mu_ag");
        names__.push_back("alpha_ag");
        names__.push_back("beta_ag");
        names__.push_back("phi_ag");
        names__.push_back("lambda_ag");
        names__.push_back("phi_t");
        names__.push_back("lambda_t");
        names__.push_back("mu0");
        names__.push_back("a_ag");
        names__.push_back("b_ag");
        names__.push_back("a_t");
        names__.push_back("b_t");
        names__.push_back("soft_z");
        names__.push_back("z");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(N_ag);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_ag);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(2);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_bama_model_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector<double> omega_ag;
        size_t dim_omega_ag_0__ = N_ag;
        for (size_t k_0__ = 0; k_0__ < dim_omega_ag_0__; ++k_0__) {
            omega_ag.push_back(in__.scalar_lub_constrain(0,1));
        }
        vector<double> omega_t;
        size_t dim_omega_t_0__ = T;
        for (size_t k_0__ = 0; k_0__ < dim_omega_t_0__; ++k_0__) {
            omega_t.push_back(in__.scalar_lub_constrain(0,1));
        }
        vector_d sigma = in__.vector_lb_constrain(0,T);
        matrix_d mu_ag = in__.matrix_lb_constrain(0,N_ag,T);
        double alpha_ag = in__.scalar_lb_constrain(0);
        double beta_ag = in__.scalar_lb_constrain(0);
        double phi_ag = in__.scalar_lub_constrain(0,1);
        double lambda_ag = in__.scalar_lb_constrain(0.10000000000000001);
        double phi_t = in__.scalar_lub_constrain(0,1);
        double lambda_t = in__.scalar_lb_constrain(0.10000000000000001);
        vector_d mu0 = in__.vector_constrain(T);
            for (int k_0__ = 0; k_0__ < N_ag; ++k_0__) {
            vars__.push_back(omega_ag[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < T; ++k_0__) {
            vars__.push_back(omega_t[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < T; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_ag; ++k_0__) {
                vars__.push_back(mu_ag(k_0__, k_1__));
                }
            }
        vars__.push_back(alpha_ag);
        vars__.push_back(beta_ag);
        vars__.push_back(phi_ag);
        vars__.push_back(lambda_ag);
        vars__.push_back(phi_t);
        vars__.push_back(lambda_t);
            for (int k_0__ = 0; k_0__ < T; ++k_0__) {
            vars__.push_back(mu0[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            double a_ag(0.0);
            (void) a_ag;  // dummy to suppress unused var warning

            stan::math::initialize(a_ag, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a_ag,DUMMY_VAR__);
            double b_ag(0.0);
            (void) b_ag;  // dummy to suppress unused var warning

            stan::math::initialize(b_ag, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b_ag,DUMMY_VAR__);
            double a_t(0.0);
            (void) a_t;  // dummy to suppress unused var warning

            stan::math::initialize(a_t, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a_t,DUMMY_VAR__);
            double b_t(0.0);
            (void) b_t;  // dummy to suppress unused var warning

            stan::math::initialize(b_t, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b_t,DUMMY_VAR__);
            validate_non_negative_index("soft_z", "2", 2);
            validate_non_negative_index("soft_z", "N", N);
            vector<vector_d> soft_z(N, (vector_d(static_cast<Eigen::VectorXd::Index>(2))));
            stan::math::initialize(soft_z, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(soft_z,DUMMY_VAR__);


            stan::math::assign(a_ag, (lambda_ag * phi_ag));
            stan::math::assign(b_ag, (lambda_ag * (1 - phi_ag)));
            stan::math::assign(a_t, (lambda_t * phi_t));
            stan::math::assign(b_t, (lambda_t * (1 - phi_t)));
            for (int n = 1; n <= N; ++n) {

                stan::math::assign(get_base1_lhs(get_base1_lhs(soft_z,n,"soft_z",1),1,"soft_z",2), (log((1 - (get_base1(omega_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),"omega_ag",1) * get_base1(omega_t,get_base1(obs_to_t,n,"obs_to_t",1),"omega_t",1)))) + normal_log(get_base1(y,n,"y",1),get_base1(mu0,get_base1(obs_to_t,n,"obs_to_t",1),"mu0",1),get_base1(sigma,get_base1(obs_to_t,n,"obs_to_t",1),"sigma",1))));
                stan::math::assign(get_base1_lhs(get_base1_lhs(soft_z,n,"soft_z",1),2,"soft_z",2), (log((get_base1(omega_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),"omega_ag",1) * get_base1(omega_t,get_base1(obs_to_t,n,"obs_to_t",1),"omega_t",1))) + normal_log(get_base1(y,n,"y",1),(get_base1(mu0,get_base1(obs_to_t,n,"obs_to_t",1),"mu0",1) + get_base1(mu_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),get_base1(obs_to_t,n,"obs_to_t",1),"mu_ag",1)),get_base1(sigma,get_base1(obs_to_t,n,"obs_to_t",1),"sigma",1))));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"a_ag",a_ag,0);
            check_greater_or_equal(function__,"b_ag",b_ag,0);
            check_greater_or_equal(function__,"a_t",a_t,0);
            check_greater_or_equal(function__,"b_t",b_t,0);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_less_or_equal(function__,"soft_z[k0__]",soft_z[k0__],0);
            }

            // write transformed parameters
        vars__.push_back(a_ag);
        vars__.push_back(b_ag);
        vars__.push_back(a_t);
        vars__.push_back(b_t);
            for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(soft_z[k_0__][k_1__]);
                }
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            validate_non_negative_index("z", "2", 2);
            validate_non_negative_index("z", "N", N);
            vector<vector_d> z(N, (vector_d(static_cast<Eigen::VectorXd::Index>(2))));
            stan::math::initialize(z, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(z,DUMMY_VAR__);


            for (int n = 1; n <= N; ++n) {

                stan::math::assign(get_base1_lhs(z,n,"z",1), softmax(get_base1(soft_z,n,"soft_z",1)));
            }

            // validate generated quantities
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"z[k0__]",z[k0__],0);
                check_less_or_equal(function__,"z[k0__]",z[k0__],1);
            }

            // write generated quantities
            for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(z[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_bama_model";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= N_ag; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_ag" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_t" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_ag; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_ag" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_t";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_t";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_t";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_t";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "soft_z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= N_ag; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_ag" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_t" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_ag; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_ag" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_t";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_t";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_t";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_t";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "soft_z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_fc_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_fc_model");
    reader.add_event(158, 158, "end", "model_fc_model");
    return reader;
}

class model_fc_model : public prob_grad {
private:
    int N;
    int T;
    vector<int> obs_to_t;
    int N_grp;
    vector<int> obs_to_grp;
    int N_ag;
    vector<int> obs_to_ag;
    int N_re;
    vector<int> obs_to_re;
    vector_d y;
public:
    model_fc_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_fc_model(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_fc_model_namespace::model_fc_model";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            context__.validate_dims("data initialization", "N", "int", context__.to_vec());
            N = int(0);
            vals_i__ = context__.vals_i("N");
            pos__ = 0;
            N = vals_i__[pos__++];
            context__.validate_dims("data initialization", "T", "int", context__.to_vec());
            T = int(0);
            vals_i__ = context__.vals_i("T");
            pos__ = 0;
            T = vals_i__[pos__++];
            validate_non_negative_index("obs_to_t", "N", N);
            context__.validate_dims("data initialization", "obs_to_t", "int", context__.to_vec(N));
            validate_non_negative_index("obs_to_t", "N", N);
            obs_to_t = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("obs_to_t");
            pos__ = 0;
            size_t obs_to_t_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < obs_to_t_limit_0__; ++i_0__) {
                obs_to_t[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "N_grp", "int", context__.to_vec());
            N_grp = int(0);
            vals_i__ = context__.vals_i("N_grp");
            pos__ = 0;
            N_grp = vals_i__[pos__++];
            validate_non_negative_index("obs_to_grp", "N", N);
            context__.validate_dims("data initialization", "obs_to_grp", "int", context__.to_vec(N));
            validate_non_negative_index("obs_to_grp", "N", N);
            obs_to_grp = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("obs_to_grp");
            pos__ = 0;
            size_t obs_to_grp_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < obs_to_grp_limit_0__; ++i_0__) {
                obs_to_grp[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "N_ag", "int", context__.to_vec());
            N_ag = int(0);
            vals_i__ = context__.vals_i("N_ag");
            pos__ = 0;
            N_ag = vals_i__[pos__++];
            validate_non_negative_index("obs_to_ag", "N", N);
            context__.validate_dims("data initialization", "obs_to_ag", "int", context__.to_vec(N));
            validate_non_negative_index("obs_to_ag", "N", N);
            obs_to_ag = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("obs_to_ag");
            pos__ = 0;
            size_t obs_to_ag_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < obs_to_ag_limit_0__; ++i_0__) {
                obs_to_ag[i_0__] = vals_i__[pos__++];
            }
            context__.validate_dims("data initialization", "N_re", "int", context__.to_vec());
            N_re = int(0);
            vals_i__ = context__.vals_i("N_re");
            pos__ = 0;
            N_re = vals_i__[pos__++];
            validate_non_negative_index("obs_to_re", "N", N);
            context__.validate_dims("data initialization", "obs_to_re", "int", context__.to_vec(N));
            validate_non_negative_index("obs_to_re", "N", N);
            obs_to_re = std::vector<int>(N,int(0));
            vals_i__ = context__.vals_i("obs_to_re");
            pos__ = 0;
            size_t obs_to_re_limit_0__ = N;
            for (size_t i_0__ = 0; i_0__ < obs_to_re_limit_0__; ++i_0__) {
                obs_to_re[i_0__] = vals_i__[pos__++];
            }
            validate_non_negative_index("y", "N", N);
            context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
            validate_non_negative_index("y", "N", N);
            y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
            vals_r__ = context__.vals_r("y");
            pos__ = 0;
            size_t y_i_vec_lim__ = N;
            for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
                y[i_vec__] = vals_r__[pos__++];
            }

            // validate, data variables
            check_greater_or_equal(function__,"N",N,1);
            check_greater_or_equal(function__,"T",T,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"obs_to_t[k0__]",obs_to_t[k0__],1);
            }
            check_greater_or_equal(function__,"N_grp",N_grp,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"obs_to_grp[k0__]",obs_to_grp[k0__],1);
            }
            check_greater_or_equal(function__,"N_ag",N_ag,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"obs_to_ag[k0__]",obs_to_ag[k0__],1);
            }
            check_greater_or_equal(function__,"N_re",N_re,1);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"obs_to_re[k0__]",obs_to_re[k0__],1);
            }
            // initialize data variables


            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            validate_non_negative_index("omega_grp", "N_grp", N_grp);
            num_params_r__ += N_grp;
            validate_non_negative_index("omega_ag", "N_ag", N_ag);
            num_params_r__ += N_ag;
            validate_non_negative_index("omega_re", "N_re", N_re);
            num_params_r__ += N_re;
            validate_non_negative_index("omega_t", "T", T);
            num_params_r__ += T;
            validate_non_negative_index("sigma", "T", T);
            num_params_r__ += T;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
        validate_non_negative_index("mu_ag", "N_ag", N_ag);
            validate_non_negative_index("mu_ag", "T", T);
            num_params_r__ += N_ag * T;
        validate_non_negative_index("mu_re", "N_re", N_re);
            validate_non_negative_index("mu_re", "T", T);
            num_params_r__ += N_re * T;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            ++num_params_r__;
            validate_non_negative_index("mu0", "T", T);
            num_params_r__ += T;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_fc_model() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("omega_grp")))
            throw std::runtime_error("variable omega_grp missing");
        vals_r__ = context__.vals_r("omega_grp");
        pos__ = 0U;
        validate_non_negative_index("omega_grp", "N_grp", N_grp);
        context__.validate_dims("initialization", "omega_grp", "double", context__.to_vec(N_grp));
        std::vector<double> omega_grp(N_grp,double(0));
        for (int i0__ = 0U; i0__ < N_grp; ++i0__)
            omega_grp[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_grp; ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,omega_grp[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable omega_grp: ") + e.what());
        }

        if (!(context__.contains_r("omega_ag")))
            throw std::runtime_error("variable omega_ag missing");
        vals_r__ = context__.vals_r("omega_ag");
        pos__ = 0U;
        validate_non_negative_index("omega_ag", "N_ag", N_ag);
        context__.validate_dims("initialization", "omega_ag", "double", context__.to_vec(N_ag));
        std::vector<double> omega_ag(N_ag,double(0));
        for (int i0__ = 0U; i0__ < N_ag; ++i0__)
            omega_ag[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_ag; ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,omega_ag[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable omega_ag: ") + e.what());
        }

        if (!(context__.contains_r("omega_re")))
            throw std::runtime_error("variable omega_re missing");
        vals_r__ = context__.vals_r("omega_re");
        pos__ = 0U;
        validate_non_negative_index("omega_re", "N_re", N_re);
        context__.validate_dims("initialization", "omega_re", "double", context__.to_vec(N_re));
        std::vector<double> omega_re(N_re,double(0));
        for (int i0__ = 0U; i0__ < N_re; ++i0__)
            omega_re[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < N_re; ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,omega_re[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable omega_re: ") + e.what());
        }

        if (!(context__.contains_r("omega_t")))
            throw std::runtime_error("variable omega_t missing");
        vals_r__ = context__.vals_r("omega_t");
        pos__ = 0U;
        validate_non_negative_index("omega_t", "T", T);
        context__.validate_dims("initialization", "omega_t", "double", context__.to_vec(T));
        std::vector<double> omega_t(T,double(0));
        for (int i0__ = 0U; i0__ < T; ++i0__)
            omega_t[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < T; ++i0__)
            try {
            writer__.scalar_lub_unconstrain(0,1,omega_t[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable omega_t: ") + e.what());
        }

        if (!(context__.contains_r("sigma")))
            throw std::runtime_error("variable sigma missing");
        vals_r__ = context__.vals_r("sigma");
        pos__ = 0U;
        validate_non_negative_index("sigma", "T", T);
        context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(T));
        vector_d sigma(static_cast<Eigen::VectorXd::Index>(T));
        for (int j1__ = 0U; j1__ < T; ++j1__)
            sigma(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_lb_unconstrain(0,sigma);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
        }

        if (!(context__.contains_r("alpha_ag")))
            throw std::runtime_error("variable alpha_ag missing");
        vals_r__ = context__.vals_r("alpha_ag");
        pos__ = 0U;
        context__.validate_dims("initialization", "alpha_ag", "double", context__.to_vec());
        double alpha_ag(0);
        alpha_ag = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,alpha_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_ag: ") + e.what());
        }

        if (!(context__.contains_r("beta_ag")))
            throw std::runtime_error("variable beta_ag missing");
        vals_r__ = context__.vals_r("beta_ag");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta_ag", "double", context__.to_vec());
        double beta_ag(0);
        beta_ag = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,beta_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_ag: ") + e.what());
        }

        if (!(context__.contains_r("alpha_re")))
            throw std::runtime_error("variable alpha_re missing");
        vals_r__ = context__.vals_r("alpha_re");
        pos__ = 0U;
        context__.validate_dims("initialization", "alpha_re", "double", context__.to_vec());
        double alpha_re(0);
        alpha_re = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,alpha_re);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_re: ") + e.what());
        }

        if (!(context__.contains_r("beta_re")))
            throw std::runtime_error("variable beta_re missing");
        vals_r__ = context__.vals_r("beta_re");
        pos__ = 0U;
        context__.validate_dims("initialization", "beta_re", "double", context__.to_vec());
        double beta_re(0);
        beta_re = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0,beta_re);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta_re: ") + e.what());
        }

        if (!(context__.contains_r("mu_ag")))
            throw std::runtime_error("variable mu_ag missing");
        vals_r__ = context__.vals_r("mu_ag");
        pos__ = 0U;
        validate_non_negative_index("mu_ag", "N_ag", N_ag);
        validate_non_negative_index("mu_ag", "T", T);
        context__.validate_dims("initialization", "mu_ag", "matrix_d", context__.to_vec(N_ag,T));
        matrix_d mu_ag(static_cast<Eigen::VectorXd::Index>(N_ag),static_cast<Eigen::VectorXd::Index>(T));
        for (int j2__ = 0U; j2__ < T; ++j2__)
            for (int j1__ = 0U; j1__ < N_ag; ++j1__)
                mu_ag(j1__,j2__) = vals_r__[pos__++];
        try {
            writer__.matrix_lb_unconstrain(0,mu_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_ag: ") + e.what());
        }

        if (!(context__.contains_r("mu_re")))
            throw std::runtime_error("variable mu_re missing");
        vals_r__ = context__.vals_r("mu_re");
        pos__ = 0U;
        validate_non_negative_index("mu_re", "N_re", N_re);
        validate_non_negative_index("mu_re", "T", T);
        context__.validate_dims("initialization", "mu_re", "matrix_d", context__.to_vec(N_re,T));
        matrix_d mu_re(static_cast<Eigen::VectorXd::Index>(N_re),static_cast<Eigen::VectorXd::Index>(T));
        for (int j2__ = 0U; j2__ < T; ++j2__)
            for (int j1__ = 0U; j1__ < N_re; ++j1__)
                mu_re(j1__,j2__) = vals_r__[pos__++];
        try {
            writer__.matrix_lb_unconstrain(0,mu_re);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu_re: ") + e.what());
        }

        if (!(context__.contains_r("phi_grp")))
            throw std::runtime_error("variable phi_grp missing");
        vals_r__ = context__.vals_r("phi_grp");
        pos__ = 0U;
        context__.validate_dims("initialization", "phi_grp", "double", context__.to_vec());
        double phi_grp(0);
        phi_grp = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,phi_grp);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_grp: ") + e.what());
        }

        if (!(context__.contains_r("lambda_grp")))
            throw std::runtime_error("variable lambda_grp missing");
        vals_r__ = context__.vals_r("lambda_grp");
        pos__ = 0U;
        context__.validate_dims("initialization", "lambda_grp", "double", context__.to_vec());
        double lambda_grp(0);
        lambda_grp = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0.10000000000000001,lambda_grp);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_grp: ") + e.what());
        }

        if (!(context__.contains_r("phi_ag")))
            throw std::runtime_error("variable phi_ag missing");
        vals_r__ = context__.vals_r("phi_ag");
        pos__ = 0U;
        context__.validate_dims("initialization", "phi_ag", "double", context__.to_vec());
        double phi_ag(0);
        phi_ag = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,phi_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_ag: ") + e.what());
        }

        if (!(context__.contains_r("lambda_ag")))
            throw std::runtime_error("variable lambda_ag missing");
        vals_r__ = context__.vals_r("lambda_ag");
        pos__ = 0U;
        context__.validate_dims("initialization", "lambda_ag", "double", context__.to_vec());
        double lambda_ag(0);
        lambda_ag = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0.10000000000000001,lambda_ag);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_ag: ") + e.what());
        }

        if (!(context__.contains_r("phi_re")))
            throw std::runtime_error("variable phi_re missing");
        vals_r__ = context__.vals_r("phi_re");
        pos__ = 0U;
        context__.validate_dims("initialization", "phi_re", "double", context__.to_vec());
        double phi_re(0);
        phi_re = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,phi_re);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_re: ") + e.what());
        }

        if (!(context__.contains_r("lambda_re")))
            throw std::runtime_error("variable lambda_re missing");
        vals_r__ = context__.vals_r("lambda_re");
        pos__ = 0U;
        context__.validate_dims("initialization", "lambda_re", "double", context__.to_vec());
        double lambda_re(0);
        lambda_re = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0.10000000000000001,lambda_re);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_re: ") + e.what());
        }

        if (!(context__.contains_r("phi_t")))
            throw std::runtime_error("variable phi_t missing");
        vals_r__ = context__.vals_r("phi_t");
        pos__ = 0U;
        context__.validate_dims("initialization", "phi_t", "double", context__.to_vec());
        double phi_t(0);
        phi_t = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(0,1,phi_t);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi_t: ") + e.what());
        }

        if (!(context__.contains_r("lambda_t")))
            throw std::runtime_error("variable lambda_t missing");
        vals_r__ = context__.vals_r("lambda_t");
        pos__ = 0U;
        context__.validate_dims("initialization", "lambda_t", "double", context__.to_vec());
        double lambda_t(0);
        lambda_t = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0.10000000000000001,lambda_t);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lambda_t: ") + e.what());
        }

        if (!(context__.contains_r("mu0")))
            throw std::runtime_error("variable mu0 missing");
        vals_r__ = context__.vals_r("mu0");
        pos__ = 0U;
        validate_non_negative_index("mu0", "T", T);
        context__.validate_dims("initialization", "mu0", "vector_d", context__.to_vec(T));
        vector_d mu0(static_cast<Eigen::VectorXd::Index>(T));
        for (int j1__ = 0U; j1__ < T; ++j1__)
            mu0(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(mu0);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mu0: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            vector<T__> omega_grp;
            size_t dim_omega_grp_0__ = N_grp;
            omega_grp.reserve(dim_omega_grp_0__);
            for (size_t k_0__ = 0; k_0__ < dim_omega_grp_0__; ++k_0__) {
                if (jacobian__)
                    omega_grp.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    omega_grp.push_back(in__.scalar_lub_constrain(0,1));
            }

            vector<T__> omega_ag;
            size_t dim_omega_ag_0__ = N_ag;
            omega_ag.reserve(dim_omega_ag_0__);
            for (size_t k_0__ = 0; k_0__ < dim_omega_ag_0__; ++k_0__) {
                if (jacobian__)
                    omega_ag.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    omega_ag.push_back(in__.scalar_lub_constrain(0,1));
            }

            vector<T__> omega_re;
            size_t dim_omega_re_0__ = N_re;
            omega_re.reserve(dim_omega_re_0__);
            for (size_t k_0__ = 0; k_0__ < dim_omega_re_0__; ++k_0__) {
                if (jacobian__)
                    omega_re.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    omega_re.push_back(in__.scalar_lub_constrain(0,1));
            }

            vector<T__> omega_t;
            size_t dim_omega_t_0__ = T;
            omega_t.reserve(dim_omega_t_0__);
            for (size_t k_0__ = 0; k_0__ < dim_omega_t_0__; ++k_0__) {
                if (jacobian__)
                    omega_t.push_back(in__.scalar_lub_constrain(0,1,lp__));
                else
                    omega_t.push_back(in__.scalar_lub_constrain(0,1));
            }

            Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
            (void) sigma;  // dummy to suppress unused var warning
            if (jacobian__)
                sigma = in__.vector_lb_constrain(0,T,lp__);
            else
                sigma = in__.vector_lb_constrain(0,T);

            T__ alpha_ag;
            (void) alpha_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_ag = in__.scalar_lb_constrain(0,lp__);
            else
                alpha_ag = in__.scalar_lb_constrain(0);

            T__ beta_ag;
            (void) beta_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_ag = in__.scalar_lb_constrain(0,lp__);
            else
                beta_ag = in__.scalar_lb_constrain(0);

            T__ alpha_re;
            (void) alpha_re;  // dummy to suppress unused var warning
            if (jacobian__)
                alpha_re = in__.scalar_lb_constrain(0,lp__);
            else
                alpha_re = in__.scalar_lb_constrain(0);

            T__ beta_re;
            (void) beta_re;  // dummy to suppress unused var warning
            if (jacobian__)
                beta_re = in__.scalar_lb_constrain(0,lp__);
            else
                beta_re = in__.scalar_lb_constrain(0);

            Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  mu_ag;
            (void) mu_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_ag = in__.matrix_lb_constrain(0,N_ag,T,lp__);
            else
                mu_ag = in__.matrix_lb_constrain(0,N_ag,T);

            Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  mu_re;
            (void) mu_re;  // dummy to suppress unused var warning
            if (jacobian__)
                mu_re = in__.matrix_lb_constrain(0,N_re,T,lp__);
            else
                mu_re = in__.matrix_lb_constrain(0,N_re,T);

            T__ phi_grp;
            (void) phi_grp;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_grp = in__.scalar_lub_constrain(0,1,lp__);
            else
                phi_grp = in__.scalar_lub_constrain(0,1);

            T__ lambda_grp;
            (void) lambda_grp;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_grp = in__.scalar_lb_constrain(0.10000000000000001,lp__);
            else
                lambda_grp = in__.scalar_lb_constrain(0.10000000000000001);

            T__ phi_ag;
            (void) phi_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_ag = in__.scalar_lub_constrain(0,1,lp__);
            else
                phi_ag = in__.scalar_lub_constrain(0,1);

            T__ lambda_ag;
            (void) lambda_ag;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_ag = in__.scalar_lb_constrain(0.10000000000000001,lp__);
            else
                lambda_ag = in__.scalar_lb_constrain(0.10000000000000001);

            T__ phi_re;
            (void) phi_re;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_re = in__.scalar_lub_constrain(0,1,lp__);
            else
                phi_re = in__.scalar_lub_constrain(0,1);

            T__ lambda_re;
            (void) lambda_re;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_re = in__.scalar_lb_constrain(0.10000000000000001,lp__);
            else
                lambda_re = in__.scalar_lb_constrain(0.10000000000000001);

            T__ phi_t;
            (void) phi_t;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_t = in__.scalar_lub_constrain(0,1,lp__);
            else
                phi_t = in__.scalar_lub_constrain(0,1);

            T__ lambda_t;
            (void) lambda_t;  // dummy to suppress unused var warning
            if (jacobian__)
                lambda_t = in__.scalar_lb_constrain(0.10000000000000001,lp__);
            else
                lambda_t = in__.scalar_lb_constrain(0.10000000000000001);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  mu0;
            (void) mu0;  // dummy to suppress unused var warning
            if (jacobian__)
                mu0 = in__.vector_constrain(T,lp__);
            else
                mu0 = in__.vector_constrain(T);


            // transformed parameters
            T__ a_grp;
            (void) a_grp;  // dummy to suppress unused var warning

            stan::math::initialize(a_grp, DUMMY_VAR__);
            stan::math::fill(a_grp,DUMMY_VAR__);
            T__ b_grp;
            (void) b_grp;  // dummy to suppress unused var warning

            stan::math::initialize(b_grp, DUMMY_VAR__);
            stan::math::fill(b_grp,DUMMY_VAR__);
            T__ a_ag;
            (void) a_ag;  // dummy to suppress unused var warning

            stan::math::initialize(a_ag, DUMMY_VAR__);
            stan::math::fill(a_ag,DUMMY_VAR__);
            T__ b_ag;
            (void) b_ag;  // dummy to suppress unused var warning

            stan::math::initialize(b_ag, DUMMY_VAR__);
            stan::math::fill(b_ag,DUMMY_VAR__);
            T__ a_re;
            (void) a_re;  // dummy to suppress unused var warning

            stan::math::initialize(a_re, DUMMY_VAR__);
            stan::math::fill(a_re,DUMMY_VAR__);
            T__ b_re;
            (void) b_re;  // dummy to suppress unused var warning

            stan::math::initialize(b_re, DUMMY_VAR__);
            stan::math::fill(b_re,DUMMY_VAR__);
            T__ a_t;
            (void) a_t;  // dummy to suppress unused var warning

            stan::math::initialize(a_t, DUMMY_VAR__);
            stan::math::fill(a_t,DUMMY_VAR__);
            T__ b_t;
            (void) b_t;  // dummy to suppress unused var warning

            stan::math::initialize(b_t, DUMMY_VAR__);
            stan::math::fill(b_t,DUMMY_VAR__);
            validate_non_negative_index("soft_z", "2", 2);
            validate_non_negative_index("soft_z", "N", N);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > soft_z(N, (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(2))));
            stan::math::initialize(soft_z, DUMMY_VAR__);
            stan::math::fill(soft_z,DUMMY_VAR__);
            validate_non_negative_index("mu_ar", "N_ag", N_ag);
            validate_non_negative_index("mu_ar", "N_re", N_re);
            validate_non_negative_index("mu_ar", "T", T);
            vector<Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic> > mu_ar(T, (Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(N_ag),static_cast<Eigen::VectorXd::Index>(N_re))));
            stan::math::initialize(mu_ar, DUMMY_VAR__);
            stan::math::fill(mu_ar,DUMMY_VAR__);


            stan::math::assign(a_grp, (lambda_grp * phi_grp));
            stan::math::assign(b_grp, (lambda_grp * (1 - phi_grp)));
            stan::math::assign(a_ag, (lambda_ag * phi_ag));
            stan::math::assign(b_ag, (lambda_ag * (1 - phi_ag)));
            stan::math::assign(a_re, (lambda_re * phi_re));
            stan::math::assign(b_re, (lambda_re * (1 - phi_re)));
            stan::math::assign(a_t, (lambda_t * phi_t));
            stan::math::assign(b_t, (lambda_t * (1 - phi_t)));
            for (int n_a = 1; n_a <= N_ag; ++n_a) {

                for (int n_r = 1; n_r <= N_re; ++n_r) {

                    for (int t = 1; t <= T; ++t) {

                        stan::math::assign(get_base1_lhs(get_base1_lhs(mu_ar,t,"mu_ar",1),n_a,n_r,"mu_ar",2), (get_base1(mu_ag,n_a,t,"mu_ag",1) + get_base1(mu_re,n_r,t,"mu_re",1)));
                    }
                }
            }
            for (int n = 1; n <= N; ++n) {

                stan::math::assign(get_base1_lhs(get_base1_lhs(soft_z,n,"soft_z",1),1,"soft_z",2), (log((1 - (((get_base1(omega_grp,get_base1(obs_to_grp,n,"obs_to_grp",1),"omega_grp",1) * get_base1(omega_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),"omega_ag",1)) * get_base1(omega_re,get_base1(obs_to_re,n,"obs_to_re",1),"omega_re",1)) * get_base1(omega_t,get_base1(obs_to_t,n,"obs_to_t",1),"omega_t",1)))) + normal_log(get_base1(y,n,"y",1),get_base1(mu0,get_base1(obs_to_t,n,"obs_to_t",1),"mu0",1),get_base1(sigma,get_base1(obs_to_t,n,"obs_to_t",1),"sigma",1))));
                stan::math::assign(get_base1_lhs(get_base1_lhs(soft_z,n,"soft_z",1),2,"soft_z",2), (log((((get_base1(omega_grp,get_base1(obs_to_grp,n,"obs_to_grp",1),"omega_grp",1) * get_base1(omega_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),"omega_ag",1)) * get_base1(omega_re,get_base1(obs_to_re,n,"obs_to_re",1),"omega_re",1)) * get_base1(omega_t,get_base1(obs_to_t,n,"obs_to_t",1),"omega_t",1))) + normal_log(get_base1(y,n,"y",1),(get_base1(mu0,get_base1(obs_to_t,n,"obs_to_t",1),"mu0",1) + get_base1(get_base1(mu_ar,get_base1(obs_to_t,n,"obs_to_t",1),"mu_ar",1),get_base1(obs_to_ag,n,"obs_to_ag",1),get_base1(obs_to_re,n,"obs_to_re",1),"mu_ar",2)),get_base1(sigma,get_base1(obs_to_t,n,"obs_to_t",1),"sigma",1))));
            }

            // validate transformed parameters
            if (stan::math::is_uninitialized(a_grp)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: a_grp";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(b_grp)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b_grp";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(a_ag)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: a_ag";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(b_ag)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b_ag";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(a_re)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: a_re";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(b_re)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b_re";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(a_t)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: a_t";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(b_t)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: b_t";
                throw std::runtime_error(msg__.str());
            }
            for (int i0__ = 0; i0__ < N; ++i0__) {
                for (int i1__ = 0; i1__ < 2; ++i1__) {
                    if (stan::math::is_uninitialized(soft_z[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: soft_z" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < T; ++i0__) {
                for (int i1__ = 0; i1__ < N_ag; ++i1__) {
                    for (int i2__ = 0; i2__ < N_re; ++i2__) {
                        if (stan::math::is_uninitialized(mu_ar[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: mu_ar" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            check_greater_or_equal(function__,"a_grp",a_grp,0);
            check_greater_or_equal(function__,"b_grp",b_grp,0);
            check_greater_or_equal(function__,"a_ag",a_ag,0);
            check_greater_or_equal(function__,"b_ag",b_ag,0);
            check_greater_or_equal(function__,"a_re",a_re,0);
            check_greater_or_equal(function__,"b_re",b_re,0);
            check_greater_or_equal(function__,"a_t",a_t,0);
            check_greater_or_equal(function__,"b_t",b_t,0);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_less_or_equal(function__,"soft_z[k0__]",soft_z[k0__],0);
            }
            for (int k0__ = 0; k0__ < T; ++k0__) {
                check_greater_or_equal(function__,"mu_ar[k0__]",mu_ar[k0__],0);
            }

            // model body

            lp_accum__.add(cauchy_log<propto__>(sigma, 0, 10));
            lp_accum__.add(beta_log<propto__>(phi_grp, 1, 1));
            lp_accum__.add(pareto_log<propto__>(lambda_grp, 0.10000000000000001, 1.5));
            lp_accum__.add(beta_log<propto__>(phi_ag, 1, 1));
            lp_accum__.add(pareto_log<propto__>(lambda_ag, 0.10000000000000001, 1.5));
            lp_accum__.add(beta_log<propto__>(phi_re, 1, 1));
            lp_accum__.add(pareto_log<propto__>(lambda_re, 0.10000000000000001, 1.5));
            lp_accum__.add(beta_log<propto__>(phi_t, 1, 1));
            lp_accum__.add(pareto_log<propto__>(lambda_t, 0.10000000000000001, 1.5));
            lp_accum__.add(beta_log<propto__>(omega_grp, a_grp, b_grp));
            lp_accum__.add(beta_log<propto__>(omega_ag, a_ag, b_ag));
            lp_accum__.add(beta_log<propto__>(omega_re, a_re, b_re));
            lp_accum__.add(beta_log<propto__>(omega_t, a_t, b_t));
            lp_accum__.add(uniform_log<propto__>(alpha_ag, 0, 1000));
            lp_accum__.add(uniform_log<propto__>(beta_ag, 0, 1000));
            lp_accum__.add(uniform_log<propto__>(alpha_re, 0, 1000));
            lp_accum__.add(uniform_log<propto__>(beta_re, 0, 1000));
            lp_accum__.add(normal_log<propto__>(mu0, 0, 0.5));
            for (int n_a = 1; n_a <= N_ag; ++n_a) {

                lp_accum__.add(gamma_log<propto__>(stan::model::rvalue(mu_ag, stan::model::cons_list(stan::model::index_uni(n_a), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "mu_ag"), alpha_ag, beta_ag));
            }
            for (int n_r = 1; n_r <= N_re; ++n_r) {

                lp_accum__.add(gamma_log<propto__>(stan::model::rvalue(mu_re, stan::model::cons_list(stan::model::index_uni(n_r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "mu_re"), alpha_re, beta_re));
            }
            for (int n = 1; n <= N; ++n) {

                lp_accum__.add(log_sum_exp(get_base1(soft_z,n,"soft_z",1)));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("omega_grp");
        names__.push_back("omega_ag");
        names__.push_back("omega_re");
        names__.push_back("omega_t");
        names__.push_back("sigma");
        names__.push_back("alpha_ag");
        names__.push_back("beta_ag");
        names__.push_back("alpha_re");
        names__.push_back("beta_re");
        names__.push_back("mu_ag");
        names__.push_back("mu_re");
        names__.push_back("phi_grp");
        names__.push_back("lambda_grp");
        names__.push_back("phi_ag");
        names__.push_back("lambda_ag");
        names__.push_back("phi_re");
        names__.push_back("lambda_re");
        names__.push_back("phi_t");
        names__.push_back("lambda_t");
        names__.push_back("mu0");
        names__.push_back("a_grp");
        names__.push_back("b_grp");
        names__.push_back("a_ag");
        names__.push_back("b_ag");
        names__.push_back("a_re");
        names__.push_back("b_re");
        names__.push_back("a_t");
        names__.push_back("b_t");
        names__.push_back("soft_z");
        names__.push_back("mu_ar");
        names__.push_back("z");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(N_grp);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_ag);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_re);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_ag);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N_re);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(T);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(2);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(T);
        dims__.push_back(N_ag);
        dims__.push_back(N_re);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(N);
        dims__.push_back(2);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_fc_model_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector<double> omega_grp;
        size_t dim_omega_grp_0__ = N_grp;
        for (size_t k_0__ = 0; k_0__ < dim_omega_grp_0__; ++k_0__) {
            omega_grp.push_back(in__.scalar_lub_constrain(0,1));
        }
        vector<double> omega_ag;
        size_t dim_omega_ag_0__ = N_ag;
        for (size_t k_0__ = 0; k_0__ < dim_omega_ag_0__; ++k_0__) {
            omega_ag.push_back(in__.scalar_lub_constrain(0,1));
        }
        vector<double> omega_re;
        size_t dim_omega_re_0__ = N_re;
        for (size_t k_0__ = 0; k_0__ < dim_omega_re_0__; ++k_0__) {
            omega_re.push_back(in__.scalar_lub_constrain(0,1));
        }
        vector<double> omega_t;
        size_t dim_omega_t_0__ = T;
        for (size_t k_0__ = 0; k_0__ < dim_omega_t_0__; ++k_0__) {
            omega_t.push_back(in__.scalar_lub_constrain(0,1));
        }
        vector_d sigma = in__.vector_lb_constrain(0,T);
        double alpha_ag = in__.scalar_lb_constrain(0);
        double beta_ag = in__.scalar_lb_constrain(0);
        double alpha_re = in__.scalar_lb_constrain(0);
        double beta_re = in__.scalar_lb_constrain(0);
        matrix_d mu_ag = in__.matrix_lb_constrain(0,N_ag,T);
        matrix_d mu_re = in__.matrix_lb_constrain(0,N_re,T);
        double phi_grp = in__.scalar_lub_constrain(0,1);
        double lambda_grp = in__.scalar_lb_constrain(0.10000000000000001);
        double phi_ag = in__.scalar_lub_constrain(0,1);
        double lambda_ag = in__.scalar_lb_constrain(0.10000000000000001);
        double phi_re = in__.scalar_lub_constrain(0,1);
        double lambda_re = in__.scalar_lb_constrain(0.10000000000000001);
        double phi_t = in__.scalar_lub_constrain(0,1);
        double lambda_t = in__.scalar_lb_constrain(0.10000000000000001);
        vector_d mu0 = in__.vector_constrain(T);
            for (int k_0__ = 0; k_0__ < N_grp; ++k_0__) {
            vars__.push_back(omega_grp[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N_ag; ++k_0__) {
            vars__.push_back(omega_ag[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < N_re; ++k_0__) {
            vars__.push_back(omega_re[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < T; ++k_0__) {
            vars__.push_back(omega_t[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < T; ++k_0__) {
            vars__.push_back(sigma[k_0__]);
            }
        vars__.push_back(alpha_ag);
        vars__.push_back(beta_ag);
        vars__.push_back(alpha_re);
        vars__.push_back(beta_re);
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_ag; ++k_0__) {
                vars__.push_back(mu_ag(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < T; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N_re; ++k_0__) {
                vars__.push_back(mu_re(k_0__, k_1__));
                }
            }
        vars__.push_back(phi_grp);
        vars__.push_back(lambda_grp);
        vars__.push_back(phi_ag);
        vars__.push_back(lambda_ag);
        vars__.push_back(phi_re);
        vars__.push_back(lambda_re);
        vars__.push_back(phi_t);
        vars__.push_back(lambda_t);
            for (int k_0__ = 0; k_0__ < T; ++k_0__) {
            vars__.push_back(mu0[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            double a_grp(0.0);
            (void) a_grp;  // dummy to suppress unused var warning

            stan::math::initialize(a_grp, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a_grp,DUMMY_VAR__);
            double b_grp(0.0);
            (void) b_grp;  // dummy to suppress unused var warning

            stan::math::initialize(b_grp, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b_grp,DUMMY_VAR__);
            double a_ag(0.0);
            (void) a_ag;  // dummy to suppress unused var warning

            stan::math::initialize(a_ag, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a_ag,DUMMY_VAR__);
            double b_ag(0.0);
            (void) b_ag;  // dummy to suppress unused var warning

            stan::math::initialize(b_ag, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b_ag,DUMMY_VAR__);
            double a_re(0.0);
            (void) a_re;  // dummy to suppress unused var warning

            stan::math::initialize(a_re, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a_re,DUMMY_VAR__);
            double b_re(0.0);
            (void) b_re;  // dummy to suppress unused var warning

            stan::math::initialize(b_re, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b_re,DUMMY_VAR__);
            double a_t(0.0);
            (void) a_t;  // dummy to suppress unused var warning

            stan::math::initialize(a_t, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(a_t,DUMMY_VAR__);
            double b_t(0.0);
            (void) b_t;  // dummy to suppress unused var warning

            stan::math::initialize(b_t, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(b_t,DUMMY_VAR__);
            validate_non_negative_index("soft_z", "2", 2);
            validate_non_negative_index("soft_z", "N", N);
            vector<vector_d> soft_z(N, (vector_d(static_cast<Eigen::VectorXd::Index>(2))));
            stan::math::initialize(soft_z, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(soft_z,DUMMY_VAR__);
            validate_non_negative_index("mu_ar", "N_ag", N_ag);
            validate_non_negative_index("mu_ar", "N_re", N_re);
            validate_non_negative_index("mu_ar", "T", T);
            vector<matrix_d> mu_ar(T, (matrix_d(static_cast<Eigen::VectorXd::Index>(N_ag),static_cast<Eigen::VectorXd::Index>(N_re))));
            stan::math::initialize(mu_ar, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(mu_ar,DUMMY_VAR__);


            stan::math::assign(a_grp, (lambda_grp * phi_grp));
            stan::math::assign(b_grp, (lambda_grp * (1 - phi_grp)));
            stan::math::assign(a_ag, (lambda_ag * phi_ag));
            stan::math::assign(b_ag, (lambda_ag * (1 - phi_ag)));
            stan::math::assign(a_re, (lambda_re * phi_re));
            stan::math::assign(b_re, (lambda_re * (1 - phi_re)));
            stan::math::assign(a_t, (lambda_t * phi_t));
            stan::math::assign(b_t, (lambda_t * (1 - phi_t)));
            for (int n_a = 1; n_a <= N_ag; ++n_a) {

                for (int n_r = 1; n_r <= N_re; ++n_r) {

                    for (int t = 1; t <= T; ++t) {

                        stan::math::assign(get_base1_lhs(get_base1_lhs(mu_ar,t,"mu_ar",1),n_a,n_r,"mu_ar",2), (get_base1(mu_ag,n_a,t,"mu_ag",1) + get_base1(mu_re,n_r,t,"mu_re",1)));
                    }
                }
            }
            for (int n = 1; n <= N; ++n) {

                stan::math::assign(get_base1_lhs(get_base1_lhs(soft_z,n,"soft_z",1),1,"soft_z",2), (log((1 - (((get_base1(omega_grp,get_base1(obs_to_grp,n,"obs_to_grp",1),"omega_grp",1) * get_base1(omega_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),"omega_ag",1)) * get_base1(omega_re,get_base1(obs_to_re,n,"obs_to_re",1),"omega_re",1)) * get_base1(omega_t,get_base1(obs_to_t,n,"obs_to_t",1),"omega_t",1)))) + normal_log(get_base1(y,n,"y",1),get_base1(mu0,get_base1(obs_to_t,n,"obs_to_t",1),"mu0",1),get_base1(sigma,get_base1(obs_to_t,n,"obs_to_t",1),"sigma",1))));
                stan::math::assign(get_base1_lhs(get_base1_lhs(soft_z,n,"soft_z",1),2,"soft_z",2), (log((((get_base1(omega_grp,get_base1(obs_to_grp,n,"obs_to_grp",1),"omega_grp",1) * get_base1(omega_ag,get_base1(obs_to_ag,n,"obs_to_ag",1),"omega_ag",1)) * get_base1(omega_re,get_base1(obs_to_re,n,"obs_to_re",1),"omega_re",1)) * get_base1(omega_t,get_base1(obs_to_t,n,"obs_to_t",1),"omega_t",1))) + normal_log(get_base1(y,n,"y",1),(get_base1(mu0,get_base1(obs_to_t,n,"obs_to_t",1),"mu0",1) + get_base1(get_base1(mu_ar,get_base1(obs_to_t,n,"obs_to_t",1),"mu_ar",1),get_base1(obs_to_ag,n,"obs_to_ag",1),get_base1(obs_to_re,n,"obs_to_re",1),"mu_ar",2)),get_base1(sigma,get_base1(obs_to_t,n,"obs_to_t",1),"sigma",1))));
            }

            // validate transformed parameters
            check_greater_or_equal(function__,"a_grp",a_grp,0);
            check_greater_or_equal(function__,"b_grp",b_grp,0);
            check_greater_or_equal(function__,"a_ag",a_ag,0);
            check_greater_or_equal(function__,"b_ag",b_ag,0);
            check_greater_or_equal(function__,"a_re",a_re,0);
            check_greater_or_equal(function__,"b_re",b_re,0);
            check_greater_or_equal(function__,"a_t",a_t,0);
            check_greater_or_equal(function__,"b_t",b_t,0);
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_less_or_equal(function__,"soft_z[k0__]",soft_z[k0__],0);
            }
            for (int k0__ = 0; k0__ < T; ++k0__) {
                check_greater_or_equal(function__,"mu_ar[k0__]",mu_ar[k0__],0);
            }

            // write transformed parameters
        vars__.push_back(a_grp);
        vars__.push_back(b_grp);
        vars__.push_back(a_ag);
        vars__.push_back(b_ag);
        vars__.push_back(a_re);
        vars__.push_back(b_re);
        vars__.push_back(a_t);
        vars__.push_back(b_t);
            for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(soft_z[k_0__][k_1__]);
                }
            }
            for (int k_2__ = 0; k_2__ < N_re; ++k_2__) {
                for (int k_1__ = 0; k_1__ < N_ag; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < T; ++k_0__) {
                    vars__.push_back(mu_ar[k_0__](k_1__, k_2__));
                    }
                }
            }

            if (!include_gqs__) return;
            // declare and define generated quantities
            validate_non_negative_index("z", "2", 2);
            validate_non_negative_index("z", "N", N);
            vector<vector_d> z(N, (vector_d(static_cast<Eigen::VectorXd::Index>(2))));
            stan::math::initialize(z, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(z,DUMMY_VAR__);


            for (int n = 1; n <= N; ++n) {

                stan::math::assign(get_base1_lhs(z,n,"z",1), softmax(get_base1(soft_z,n,"soft_z",1)));
            }

            // validate generated quantities
            for (int k0__ = 0; k0__ < N; ++k0__) {
                check_greater_or_equal(function__,"z[k0__]",z[k0__],0);
                check_less_or_equal(function__,"z[k0__]",z[k0__],1);
            }

            // write generated quantities
            for (int k_1__ = 0; k_1__ < 2; ++k_1__) {
                for (int k_0__ = 0; k_0__ < N; ++k_0__) {
                vars__.push_back(z[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_fc_model";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= N_grp; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_grp" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_ag; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_ag" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_re; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_re" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_t" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_re";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_ag; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_ag" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_re; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_re" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_grp";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_grp";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_t";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_t";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_grp";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_grp";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_t";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_t";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "soft_z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_2__ = 1; k_2__ <= N_re; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= N_ag; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mu_ar" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }

        if (!include_gqs__) return;
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= N_grp; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_grp" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_ag; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_ag" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= N_re; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_re" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "omega_t" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "beta_re";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_ag; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_ag" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= T; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N_re; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mu_re" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_grp";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_grp";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "phi_t";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "lambda_t";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "mu0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_grp";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_grp";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_ag";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_re";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "a_t";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "b_t";
        param_names__.push_back(param_name_stream__.str());
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "soft_z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_2__ = 1; k_2__ <= N_re; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= N_ag; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "mu_ar" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }

        if (!include_gqs__) return;
        for (int k_1__ = 1; k_1__ <= 2; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}




#endif
